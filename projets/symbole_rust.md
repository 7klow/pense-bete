# ü¶Ä Symboles fr√©quents en Rust ‚Äì Explications et Exemples

| Symbole | Nom / Cat√©gorie                 | Signification / Utilisation                                                                                   | Exemple                                                                                       |
|:--------|:--------------------------------|:---------------------------------------------------------------------------------------------------------------|:----------------------------------------------------------------------------------------------|
| `::`    | **Op√©rateur de chemin**          | Acc√®s √† un √©l√©ment dans un module, une fonction, une constante, etc.                                          | `std::fs::File::open("file.txt")?;`                                                           |
| `:`     | **Annotation de type / Trait**   | D√©claration de type ou contrainte de trait pour un g√©n√©rique                                                  | `let x: i32 = 5;`<br>`fn print<T: Display>(val: T) { ... }`                                   |
| `?`     | **Propagation d‚Äôerreur**         | Retourne l‚Äôerreur si `Result`/`Option` est `Err`/`None`, sinon continue                                       | `let file = File::open("foo.txt")?;`                                                          |
| `;`     | **Fin d‚Äôinstruction**            | Termine une instruction. Si omis, l'expression devient la valeur retourn√©e du bloc                           | `let x = 5;`<br>`let y = { let z = 2; z + 1 };`                                                |
| `!`     | **Macro**                        | Indique l'appel d'une macro                                                                                   | `println!("Hello");`<br>`vec![1, 2, 3]`                                                       |
| `..`    | **Plage (Range)**                | Cr√©e une plage exclusive                                                                                      | `for i in 0..10 {}`<br>`let s = &arr[2..5];`                                                   |
| `..=`   | **Plage inclusive**              | Plage qui inclut la borne sup√©rieure                                                                          | `for i in 0..=5 {}`                                                                           |
| `_`     | **Joker / Ignor√©**               | Ignore une valeur ou utilise un nom anonyme                                                                   | `let _ = func();`<br>`match x { Some(_) => ..., None => ... }`                                |
| `&`     | **R√©f√©rence**                    | Cr√©ation d'une r√©f√©rence                                                                                       | `let r = &x;`                                                                                 |
| `*`     | **D√©r√©f√©rencement**              | Acc√®s √† la valeur point√©e                                                                                      | `let y = *ptr;`                                                                               |
| `->`    | **Type de retour**               | Sp√©cifie le type retourn√© d'une fonction                                                                       | `fn sum(a: i32, b: i32) -> i32 { a + b }`                                                     |
| `=>`    | **Match / Pattern**              | S√©paration entre pattern et action dans `match`                                                               | `match x { 0 => "zero", _ => "autre" }`                                                       |
| `|`     | **Closure / Pattern OR**         | Param√®tres de closures ou plusieurs patterns combin√©s                                                          | `let c = |x| x + 1;`<br>`match n { 1 | 2 => ..., _ => ... }`                                  |
| `@`     | **Binding avec pattern**         | Donne un nom √† une valeur tout en la testant                                                                  | `match x { n @ 1..=5 => println!("{n} in range"), _ => {} }`                                  |
| `'a`    | **Dur√©e de vie (lifetime)**      | Marqueur de dur√©e de vie pour emprunts (r√©f√©rences)                                                           | `fn longest<'a>(a: &'a str, b: &'a str) -> &'a str`                                           |
| `ref`   | **R√©f√©rence dans match**         | Prend une r√©f√©rence non mutable d‚Äôun √©l√©ment dans un `match`                                                  | `match x { ref v => println!("{}", v) }`                                                      |
| `mut`   | **Mutabilit√©**                   | Rend une variable, r√©f√©rence ou binding mutable                                                               | `let mut x = 5;`<br>`let ref mut y = x;`                                                      |
| `as`    | **Cast de type**                 | Conversion explicite de types                                                                                 | `let x = 10 as f64;`                                                                          |
